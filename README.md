# freefall

A set of Python functions for simulating the rotational motion of falling objects.

These functions can help you:

* Run [Euler method](https://en.wikipedia.org/wiki/Euler_method) numerical simulations of the rotational motion of falling objects;
* Easily plot the rotational motion of objects in freefall; and
* Visualize the rotational motion of objects in freefall using `vpython`.

Enjoy!

## Table of Contents

* [Installation](#installation)
* [Example code](#example-code)
   * [example1.py](#example1py)
   * [example2.py](#example2py)
* [Documentation](#documentation)
   * [The functions](#the-functions)
      * [freefall.correct_angle()](#freefallcorrect_angle)
      * [freefall.euler_step()](#freefalleuler_step)
      * [freefall.I_sim()](#freefalli_sim)
      * [freefall.box_sim()](#freefallbox_sim)
      * [freefall.plot()](#freefallplot)
      * [freefall.visualize()](#freefallvisualize)
      * [freefall.visualize_df()](#freefallvisualize_df)
   * [Common arguments](#common-arguments)
   * [Data labelling](#data-labelling)

*This table of contents was generated by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc).*

## Installation

To use these functions, download the file `freefall.py` and put it in the directory you're working in. Then, use `import freefall` to import the functions.

You must have the `numpy`, `pandas`, and `matplotlib` modules installed to use these functions. If you've done any data processing work in Python before, chances are you already have them. If not, I recommend installing these by way of the [Anaconda distribution](https://www.anaconda.com).

Additionally, if you want to use visualization functionality, you need to have the `vpython` module installed. More information can be found [on their website](https://vpython.org). (If you don't want visualization, you don't need `vpython`.)

If you want to get up and running quickly, I recommend checking out the example code included.

Alternatively, the functions are relatively straightforward – you may find it useful to treat them as example code themselves and develop your own scripts based on them.

## Example code

### example1.py

`example1.py` showcases the cool-and-oddly-unnerving flipping effect of the [intermediate axis theorem](https://en.wikipedia.org/wiki/Tennis_racket_theorem), getting quick-and-dirty simulating, plotting and visualizing happening fast. This is a great place to start.

First, `freefall.box_sim()` is used to run the simulation. Then, plots are generated using `freefall.plot()`. Finally, you get a nice visualization with `freefall.visualize_df()`.

### example2.py

`example2.py` is slightly more complicated, running 125 simulations en masse for different initial angular velocities. CSV files of the simulation data and plots are saved in folder in the working directory.

## Documentation

### The functions

These are listed in the order found in freefall.py. Arguments are described in [Common arguments](#common-arguments).

#### freefall.correct_angle()

```python
freefall.correct_angle(n)
```

For an angle `n` in radians, the similar angle in [0, 2π) is returned. This is a simple function I developed for internal use (but can also be used elsewhere!).

#### freefall.euler_step()

```python
freefall.euler_step(I_x, I_y, I_z, x, y, z, W_x, W_y, W_z, start, stop, dt, store_every=1)
```

This generator function is the backbone used for simulation. It runs the Euler simulation, yielding each datapoint as it is calculated.

Descriptions of the arguments can be found under [Common arguments](#common-arguments).

Unlike in the other simulation functions, the initial values for `x`, `y`, and `z` can be specified here. These are the initial angular positions (angles) to start with, in radians. You will most likely want to set these to be zero, but they can be any value in [0, 2π).

Each integration step, data is yielded as a tuple in the form (t, x, y, z, W_x, W_y, W_z, a_x, a_y, a_z, j_x, j_y, j_z, n_x, n_y, n_z). The meaning of each of these values is described in [Data labelling](#data-labelling).

#### freefall.I_sim()

```python
freefall.I_sim(I_x, I_y, I_z, x, y, z, W_x, W_y, W_z, start, stop, dt, store_every=1)
```

This function is a wrapper for `freefall.euler_step()`. Instead of data being yielded by a generator function, the entire simulation is run, and a `pandas.DataFrame` is returned at the end. The columns in the DataFrame are described in [Data labelling](#data-labelling).

A description of arguments is included in [Common arguments](#common-arguments).

#### freefall.box_sim()

```python
freefall.box_sim(l, h, w, m, W_x, W_y, W_z, start, stop, dt, store_every=1)
```

This function is a wrapper for `freefall.I_sim()`. It allows you to specify the dimensions and mass of a box (cuboid) instead of the moments of inertia. (Moments of inertia are calculated internally, then passed on to `freefall.I_sim()`.

Instead of data being yielded by a generator function, as in `freefall.euler_step()`, the entire simulation is run, and a `pandas.DataFrame` and a length-3 tuple of the moments of inertia calculated are returned at the end. The columns in the DataFrame are described in [Data labelling](#data-labelling).

You may wish to gather returned values like this:

```python
df, (I_x, I_y, I_z) = freefall.box_sim(l, h, w, m, W_x, W_y, W_z, start, stop, dt, store_every=1)
```

A description of arguments is included in [Common arguments](#common-arguments).

#### freefall.plot()

```python
freefall.plot(df, start=None, stop=None, title=None, sharex=False)
```

This function will make a nice `matplotlib` figure with four subplots, showing the angular position-, angular velocity-, angular acceleration-, and angular jerk-components over time.

The figure object and a tuple of length four containing the axes are returned. You may, for instance, wish to do something like:

```python
fig, (ax1, ax2, ax3, ax4) = freefall.plot(df, start=None, stop=None, title=None, sharex=False)
```

**Arguments**:

`df` is the `pandas.DataFrame` of simulation data to plot. For instance, you might generate a DataFrame using `freefall.I_sim()` or `freefall.box_sim()`, then plot the data with `freefall.plot()`. A description of the columns used can be found in [Data labelling](#data-labelling).

`start` and `stop` can be used to set the domain. If not specified, the entire DataFrame will be plotted.

`title` is a string that will be used as a title. If not specified, no title will be used.

`sharex` can be `True` or `False`; it determines if the x-axis is shared among subplots.

#### freefall.visualize()

```python
freefall.visualize(data, l, h, w, speed=1, caption='')
```

This function will run a `vpython` visualization of a box (cuboid) undergoing motion that has been or is being simulated. The `vpython` module must be installed for this to work.

`data` is an iterator which yields tuples in the form (t, x, y, z, *args, n_x, n_y, n_z). Thus, you can use the output of `freefall.euler_step`, like

```python
freefall.visualize(freefall.euler_step(I_x, I_y, I_z, x, y, z, W_x, W_y, W_z, start, stop, dt, store_every=1), l, h, w, speed=1, caption='')
```

A description of arguments is included in [Common arguments](#common-arguments).

#### freefall.visualize_df()

```python
freefall.visualize_df(df, l, h, w, speed=1, caption='', start=None, stop=None)
```

This function is a wrapper for `freefall.visualize()` which allows you to run a `vpython` visualization using a DataFrame which has already been generated.

`df` is the `pandas.DataFrame` to use. The expected columns are described in [Data labelling](#data-labelling). The DataFrames returned by `freefall.I_sim()` and `freefall.box_sim()` are suitable.

### Common arguments

These arguments are used in the various simulation functions. Not all arguments apply to each function; refer to [The functions](#the-functions) for the specifics of each function.

Argument | Data type | Description
----------|----------|----------
`I_x`, `I_y`, and `I_z` | Int or Float | The moments of inertia (in the three dimensions).
`l`, `h`, and `w` | Int or Float | The dimensions of the box (to be) simulated, in arbitrary units. `l` corresponds to the x-axis, `h`, to the y-axis, and `w`, to the z-axis.
`m` | Int or Float | The mass of the box to be simulated. Used in calculating moments of inertia.
`W_x`, `W_y`, and `W_z` | Int or Float | The initial angular velocity component (in the three dimensions).
`start` | Int or Float | The time to start the clock at in a simulation, or the left bound for the domain in a plot. 
`stop` | Int or Float| The time at which to stop the simulation, or the left bound for the domain in a plot.
`dt` | Int or Float | The time interval between integration steps. The smaller `dt` is, the less error you will experience.
`store_every` | Int ≥ 1 | In a simulation, by setting to an integer larger than one, you can improve speed by yielding datapoints periodically; every `store_every`th datapoint will be yielded. For example, to record data every 10th integration step, set `store_every = 10`.
`caption` | String, or `''` | The caption to be used underneath a `vpython` visualization.
`speed` | Int or Float | The speed of a `vpython` visualization. This is the number of arbitrary time units per second.

### Data labelling

These labels are used throughout this documentation. 

Where `pandas.DataFrame`s are used, these are the column names used.

Label | Description
----------|----------
t | time, in arbitrary units
x | x angular position (angle)
y | y angular position (angle)
z | z angular position (angle)
W_x | x angular velocity component
W_y | y angular velocity component
W_z | z angular velocity component
a_x | x angular acceleration component
a_y | y angular acceleration component
a_z | z angular acceleration component
j_x | x angular jerk (derivative of acceleration) component
j_y | y angular jerk (derivative of acceleration) component
j_z | z angular jerk (derivative of acceleration) component
n_x | the number of times the sign of W_x has changed since the beginning of the simulation
n_y | the number of times the sign of W_y has changed since the beginning of the simulation
n_z | the number of times the sign of W_z has changed since the beginning of the simulation
